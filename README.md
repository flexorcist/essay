# Почему BIGSERIAL почти всегда лучше UUID для первичных ключей, даже в 2025 году



В современных дискуссиях по бэкенду часто звучит утверждене: "UUID это правильный первичный ключ для распределенных систем". Это утверждение звучит современно, масштабируемо и перспективно. Оно также звучит как решение, за которое вас не уволят.



И все же, если отойти от архитектурных идеалов и посмотреть, как реальные системы ведут себя при реальных нагрузках, вывод будет гораздо менее лестным для UUID. Их преимущества регулярно преувеличиваются, а их недостатки - производительность, хранение, и сложность эксплуатации - недооцениваются.



UUID - это не *плохо*. У него явно есть обоснованные случаи использования. Речь идет о том, что для подавляющего большинства таблиц в prod BIGSERIAL является более прагматичным, более эффективным выбором.



## Привлекательность UUID и почему это звучит убедительно



Аргументы в пользу UUID хорошо известны.



UUID обещают глобальную уникальность без координации. Их можно генерировать где угодно, на любом узле, не затрагивая базу данных. Это кажется идеальным решением для распределенных систем, автономных клиентов, репликации, шардинга и микросервисов. UUID переносимы между базами данных, безопасны для использования в API, устойчивы к взлому и теоретически бесконечны благодаря 128-битному пространству. Более новые варианты (UUID v7, ULID и т.д.) даже обещают временную упорядоченность, устраняя традиционную проблему хаоса индексов.



В целом, все выглядит заманчиво: UUID освобождают вас от централизованной выдачи идентификаторов, упрощают слияние, скрывают внутреннюю структуру и легко масштабируются в будущем.



Проблема не в том, что эти утверждения ложны. Проблема в том, что они описывает гораздо более специфичный и редкий набор требований, чем большинству систем нужно на самом деле.



---



## Централизованная выдача идентификаторов не является реальной проблемой.



Основной аргумент в пользу UUID это децентрализация: "Я не хочу зависеть от одного места, выдающего идентификаторы".



Но посмотрите, как на самом деле работают большинство производственных систем.



Большинство записей уже проходит через небольшое количество бэкэнд-сервисов, API-шлюзов или конвейеров поступления данных. Эти службы уже взаимодействуют с PostgreSQL. PostgreSQL уже выдает значения BIGSERIAL или IDENTITY с чрезвычайно высокой скоростью, безопасно, одновременно и с незначительными накладными расходами.



На практике централизованная выдача идентификаторов не является ограничением. Это как раз таки норма. UUID решают проблему координации, которая обычно не существует.



---



## UUID не решают сложные проблемы объединения данных



Еще одно распространенное утверждение заключается в том, что UUID упрощают репликацию и offline операции.



Однако, это не так. По крайней мере, не в том смысле, на который люди надеются.



UUID гарантируют уникальность идентификатора, а не общую корректность. Два автономных клиента могут без проблем сгенерировать два разных UUID для логически одинаковой бизнес-сущности: одного и того же заказа, одного и того же клиента, одного и того же счета. При слиянии данных конфликт по-прежнему существует. Он просто принимает другую форму.



Другими словами, уникальность первичного ключа не является синонимом разрешения конфликтов. UUID устраняют один очень узкий класс коллизий, оставляя нетронутыми реальные проблемы бизнес-логики.



---



## Глобальная уникальность это чрезмерно сложное требование



Задайте себе вопрос: сколько из ваших таблиц действительно нуждаются в идентификаторах, которые являются уникальными во всех системах, во всех датацентрах, постоянно?



Для большинства компаний честный ответ - почти ни одна.



В 99% случаев достаточно уникальности в пределах одной базы данных. Даже в распределенных архитектурах глобальная уникальность обычно требуется только на границах системы: ивенты, публичные API, межсистемные ссылки. А не для каждой внутренней таблицы.



Использование UUID предполагет ограничения повсеместно, даже там, где предполагаемая выгода UUID никогда не используется.



---



## Слабые стороны: индексы, локальность и предсказуемость



Именно здесь UUID незаметно наносят ущерб.



Случайные или полуслучайные первичные ключи фрагментируют индексы B-дерева, разрушают локальность, увеличивают размер индекса. Более крупные индексы означают менее эффективное использование кэша, больше IO и более высокую задержку, особенно по мере роста таблиц и их многолетнего использования.



BIGSERIAL, напротив, почти подходит для движка базы данных:



- вставки выполняются только в конце

- индексы остаются компактными

- разделение страниц предсказуемо

- кэш используется эффективно



Неприятная правда заключается в том, что уникальность без координации обходится дорого, и UUID перекладывают эту стоимость непосредственно в самые часто используемые индексы.



---



## "Но тесты показывают, что UUID быстрее" (tps UUID = 3706 vs tps BIGINT = 3414)



Примитивные тесты могут вводить в заблуждение, и эти  результаты прекрасно это демонстрируют.



В тестах вставки одной строки с 32 одновременными клиентами вставки UUID оказались немного быстрее. На первый взгляд, это подрывает всю аргументацию. Но именно поэтому тесты без контекста ненадежны.



Кратковременные таблицы, небольшие объемы данных и однородные рабочие нагрузки скрывают реальные затраты UUID. Индекс по-прежнему небольшой. Рабочий набор помещается в кэше. Фрагментация еще не успела накопиться. В таких условиях накладные расходы UUID легко упустить из виду.



А теперь результаты массовой вставки: tps BULK UUID = 135 vs tps BULK BIGINT = 215.



При пакетной вставке 1000 строк - сценарии, гораздо более близком к реальным конвейерам поглощения, заданиям ETL и регистрации событий - картина полностью меняется. BIGINT достигает значительно более высокой пропускной способности и более низкой задержки. Именно здесь начинают иметь значение локальность и компактность индекса.



И этот разрыв только увеличивается по мере роста таблиц, запуска VACUUM, разделения страниц и давления на кэши со стороны реального трафика.



---



## UUID - не единственный способ получить децентрализованные идентификаторы



Даже если децентрализованная генерация идентификаторов  действительно необходима, UUID - далеко не единственный вариант, и зачастую не самый лучший.



Snowflake идентификаторы обеспечивают глобальную уникальность, временную упорядоченность, компактный 64-битный размер и отличную локальность индекса. Они генерируются локально, с минимальной координацией, и значительно более удобны для баз данных.



Похожие схемы самостоятельно реализуемы: BIGSERIAL с префиксом шарда, идентификатором узла или выделенными диапазонами идентификаторов. PostgreSQL не важно, получен ли int из последовательности или из сдвига битов, но для индексов это имеет значение.



Эти подходы решают ту же проблему, которую, как утверждается, решают UUID, без ущерба для хранения и производительности.



---



## Безопасность и угадываемые идентификаторы



Еще один из самых распространенных аргемнтов - безопасность. Автоинкрементные идентификаторы якобы раскрывают информацию. UUID якобы скрывают ее.



Однако, если раскрытие последовательных идентификаторов является проблемой, правильным решением будет использование внешнего идентификатора, а не злоупотребление первичным ключом. Многие системы уже отделяют внутренние ключи от публичных идентификаторов, и это отделение практически ничего не стоит по сравнению с долгосрочными затратами на раздутые индексы.



---



## В итоге



UUID - это не бесполезная концепция. Она просто излишне используются.



UUID решают узкую проблему координации, которой нет в большинстве систем, одновременно накладывая ограничения на производительность, хранение и предсказуемость. Их преимущества проявляются в дополнительных системах, в событиях, публичных идентификаторах и межсистемных ссылках, а не в качестве основного ключа по умолчанию для каждой таблицы.



BIGSERIAL, IDENTITY или Snowflake соответствуют тому, как на самом деле работают базы данных. Они масштабируются не только в теории, но и c накопленными в течение лет данными и массовыми операциями.



Вывод заключается не в том, чтобы никогда не использовать UUID. UUID должны быть использованы осознанно. Оптимизация должна происходить для той системы, которая есть на руках, а не для той, которая когда нибудь может понадобиться.

